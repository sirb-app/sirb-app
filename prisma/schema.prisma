generator client {
  provider = "prisma-client-js"
  output   = "../src/generated/prisma"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum UserRole {
  USER
  ADMIN
}

enum ContentStatus {
  PENDING
  APPROVED
  REJECTED
  DRAFT
}

enum VoteType {
  LIKE
  DISLIKE
}

enum QuestionType {
  MULTIPLE_CHOICE
  TRUE_FALSE
  SHORT_ANSWER
}

enum CompletionType {
  AUTO
  MANUAL
}

enum ReportReason {
  SPAM
  INAPPROPRIATE
  WRONG_INFO
  HARASSMENT
  COPYRIGHT
  OTHER
}

enum ReportStatus {
  PENDING
  RESOLVED
  DISMISSED
}

model User {
  id        String   @id @default(uuid())
  createdAt DateTime
  updatedAt DateTime

  name          String
  email         String    @unique
  emailVerified Boolean
  image         String?
  role          UserRole  @default(USER)
  banned        Boolean?
  banReason     String?
  banExpires    DateTime?
  totalPoints   Int       @default(0) // denormalized for performance

  sessions Session[]
  accounts Account[]

  // Content system relations
  contributedCanvases Canvas[]
  canvasVotes         CanvasVote[]

  // Quiz system relations
  quizAttempts UserQuizAttempt[]

  // Progress tracking relations
  enrollments        Enrollment[]
  canvasProgress     CanvasProgress[]
  videoProgress      VideoProgress[]
  chapterCompletions ChapterCompletion[]

  // Engagement relations
  comments     Comment[]
  commentVotes CommentVote[]

  // Moderation & reporting relations
  userPoints        UserPoints[]
  moderatedSubjects SubjectModerator[]
  reportsSubmitted  Report[]           @relation("ReportedBy")
  reportsReceived   Report[]           @relation("ReportedUser")
  reportsResolved   Report[]           @relation("ResolvedBy")

  @@map("users")
}

model Session {
  id        String   @id @default(uuid())
  createdAt DateTime
  updatedAt DateTime

  expiresAt      DateTime
  token          String   @unique
  ipAddress      String?
  userAgent      String?
  impersonatedBy String?

  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("sessions")
}

model Account {
  id        String   @id @default(uuid())
  createdAt DateTime
  updatedAt DateTime

  accountId             String
  providerId            String
  accessToken           String?
  refreshToken          String?
  idToken               String?
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?
  password              String?

  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("accounts")
}

model Verification {
  id        String    @id @default(uuid())
  createdAt DateTime?
  updatedAt DateTime?

  identifier String
  value      String
  expiresAt  DateTime

  @@map("verifications")
}

// ACADEMIC HIERARCHY

model University {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  name     String
  code     String  @unique
  imageUrl String? // University logo

  colleges College[]

  @@index([name])
  @@map("universities")
}

model College {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  name         String
  universityId Int

  university University @relation(fields: [universityId], references: [id], onDelete: Cascade)
  subjects   Subject[]

  @@index([universityId])
  @@index([name])
  @@map("colleges")
}

model Subject {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  name        String
  code        String
  description String?
  imageUrl    String? // Subject cover image
  collegeId   Int

  college     College            @relation(fields: [collegeId], references: [id], onDelete: Cascade)
  chapters    Chapter[]
  enrollments Enrollment[]
  moderators  SubjectModerator[]
  userPoints  UserPoints[]

  @@unique([code, collegeId])
  @@index([collegeId])
  @@index([name])
  @@map("subjects")
}

model Chapter {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  title       String
  description String?
  sequence    Int
  subjectId   Int

  subject            Subject             @relation(fields: [subjectId], references: [id], onDelete: Cascade)
  canvases           Canvas[]
  chapterCompletions ChapterCompletion[]

  @@unique([subjectId, sequence])
  @@index([subjectId])
  @@map("chapters")
}

// CONTENT SYSTEM - Canvas-based approach

// Junction table for content ordering across different types
model ContentBlock {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  canvasId    Int
  sequence    Int // Global sequence across all content types
  contentType String // "TEXT" | "VIDEO" | "FILE"
  contentId   Int // Points to the specific content record

  canvas Canvas @relation(fields: [canvasId], references: [id], onDelete: Cascade)

  @@unique([canvasId, sequence]) // Enforces global uniqueness!
  @@index([canvasId])
  @@index([contentType, contentId]) // For reverse lookups
  @@map("content_blocks")
}

// Text content blocks
model TextContent {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  content String @db.Text // Plain text content

  @@map("text_contents")
}

model Canvas {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  title           String
  description     String?
  imageUrl        String? // Canvas thumbnail image
  sequence        Int
  status          ContentStatus @default(PENDING)
  rejectionReason String?
  moderatorNotes  String?
  isDeleted       Boolean       @default(false)
  chapterId       Int
  contributorId   String // UUID reference to User

  // Denormalized vote counts for performance
  upvotesCount   Int @default(0)
  downvotesCount Int @default(0)
  netScore       Int @default(0)
  viewCount      Int @default(0)

  // Relations
  chapter       Chapter          @relation(fields: [chapterId], references: [id], onDelete: Cascade)
  contributor   User             @relation(fields: [contributorId], references: [id], onDelete: Cascade)
  contentBlocks ContentBlock[]
  quizzes       Quiz[]
  votes         CanvasVote[]
  userProgress  CanvasProgress[]
  comments      Comment[]
  reports       Report[]

  @@unique([chapterId, sequence])
  @@index([chapterId, status])
  @@index([contributorId])
  @@index([status])
  @@index([netScore]) // for sorting by popularity
  @@map("canvases")
}

model Video {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  title          String
  description    String?
  url            String // YouTube URL
  youtubeVideoId String // Extracted video ID
  duration       Int // seconds
  isOriginal     Boolean @default(false)

  progress VideoProgress[]

  @@map("videos")
}

model File {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  title       String
  description String?
  url         String // File storage URL
  fileSize    BigInt // bytes
  mimeType    String // application/pdf, image/png, etc
  isOriginal  Boolean @default(false)

  @@map("files")
}

model CanvasVote {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  voteType VoteType
  userId   String // UUID reference to User
  canvasId Int

  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  canvas Canvas @relation(fields: [canvasId], references: [id], onDelete: Cascade)

  @@unique([userId, canvasId]) // one vote per user per canvas
  @@index([canvasId, voteType]) // for counting votes by type
  @@map("canvas_votes")
}

// QUIZ SYSTEM

model Quiz {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  title           String
  description     String?
  instructions    String?
  timeLimit       Int? // minutes, null = no limit
  attemptsAllowed Int     @default(-1) // -1 = unlimited
  passScore       Float? // 0.0 to 1.0
  sequence        Int // Order within canvas
  canvasId        Int

  canvas    Canvas            @relation(fields: [canvasId], references: [id], onDelete: Cascade)
  questions QuizQuestion[]
  attempts  UserQuizAttempt[]

  @@unique([canvasId, sequence])
  @@index([canvasId])
  @@map("quizzes")
}

model QuizQuestion {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  questionText String
  questionType QuestionType
  points       Int          @default(1)
  sequence     Int // question order within quiz
  quizId       Int

  quiz    Quiz         @relation(fields: [quizId], references: [id], onDelete: Cascade)
  options QuizOption[]
  answers UserAnswer[]

  @@unique([quizId, sequence]) // prevent duplicate question ordering
  @@index([quizId]) // for loading quiz questions
  @@map("quiz_questions")
}

model QuizOption {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  optionText String
  isCorrect  Boolean @default(false)
  sequence   Int // option order within question
  questionId Int

  question QuizQuestion @relation(fields: [questionId], references: [id], onDelete: Cascade)
  answers  UserAnswer[]

  @@unique([questionId, sequence]) // prevent duplicate option ordering
  @@index([questionId]) // for loading question options
  @@map("quiz_options")
}

model UserQuizAttempt {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  score       Float? // 0.0 to 1.0, calculated after completion
  maxScore    Int // total points possible
  startedAt   DateTime  @default(now())
  completedAt DateTime? // null = in progress
  userId      String // UUID reference to User
  quizId      Int

  user    User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  quiz    Quiz         @relation(fields: [quizId], references: [id], onDelete: Cascade)
  answers UserAnswer[]

  @@index([userId, quizId]) // for user's attempts on specific quiz
  @@index([quizId]) // for quiz statistics
  @@map("user_quiz_attempts")
}

model UserAnswer {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  selectedOptionId Int? // for multiple_choice/true_false
  textAnswer       String? // for short_answer
  isCorrect        Boolean? // calculated after submission
  attemptId        Int
  questionId       Int

  attempt  UserQuizAttempt @relation(fields: [attemptId], references: [id], onDelete: Cascade)
  question QuizQuestion    @relation(fields: [questionId], references: [id], onDelete: Cascade)
  option   QuizOption?     @relation(fields: [selectedOptionId], references: [id], onDelete: SetNull)

  @@unique([attemptId, questionId]) // one answer per question per attempt
  @@index([attemptId]) // for loading attempt answers
  @@map("user_answers")
}

// PROGRESS TRACKING

model Enrollment {
  id         Int      @id @default(autoincrement())
  enrolledAt DateTime @default(now())
  userId     String // UUID reference to User
  subjectId  Int

  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  subject Subject @relation(fields: [subjectId], references: [id], onDelete: Cascade)

  @@unique([userId, subjectId]) // one enrollment per user per subject
  @@index([subjectId]) // for subject enrollment counts
  @@index([userId]) // for user's enrolled subjects
  @@map("enrollments")
}

model CanvasProgress {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  completedAt  DateTime? // null = not completed
  lastAccessed DateTime  @default(now())
  lastViewed   DateTime  @default(now()) // for view tracking
  userId       String // UUID reference to User
  canvasId     Int

  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  canvas Canvas @relation(fields: [canvasId], references: [id], onDelete: Cascade)

  @@unique([userId, canvasId]) // one progress record per user per canvas
  @@index([userId, completedAt]) // for user progress queries
  @@index([canvasId]) // for canvas completion statistics
  @@map("canvas_progress")
}

model VideoProgress {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  lastPosition Int      @default(0) // seconds into video
  lastAccessed DateTime @default(now())
  userId       String // UUID reference to User
  videoId      Int

  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)
  video Video @relation(fields: [videoId], references: [id], onDelete: Cascade)

  @@unique([userId, videoId]) // one progress record per user per video
  @@index([userId]) // for user video progress queries
  @@index([videoId]) // for video statistics
  @@map("video_progress")
}

model ChapterCompletion {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  completedAt    DateTime? // null = not completed
  completionType CompletionType @default(AUTO) // 'manual' or 'auto'
  userId         String // UUID reference to User
  chapterId      Int

  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  chapter Chapter @relation(fields: [chapterId], references: [id], onDelete: Cascade)

  @@unique([userId, chapterId]) // one completion record per user per chapter
  @@index([userId]) // for user's completed chapters
  @@index([chapterId]) // for chapter completion statistics
  @@map("chapter_completions")
}

// ENGAGEMENT FEATURES

model Comment {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  text            String
  isAnnouncement  Boolean   @default(false) // for moderator/contributor announcements
  isPinned        Boolean   @default(false)
  isDeleted       Boolean   @default(false) // soft delete
  editedAt        DateTime?
  userId          String // UUID reference to User
  canvasId        Int
  parentCommentId Int? // for replies

  // Denormalized vote counts for performance
  upvotesCount   Int @default(0)
  downvotesCount Int @default(0)
  netScore       Int @default(0)

  user          User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  canvas        Canvas        @relation(fields: [canvasId], references: [id], onDelete: Cascade)
  parentComment Comment?      @relation("CommentReplies", fields: [parentCommentId], references: [id], onDelete: Cascade)
  replies       Comment[]     @relation("CommentReplies")
  votes         CommentVote[]
  reports       Report[]

  @@index([canvasId, isDeleted, createdAt]) // for canvas comments (excluding deleted)
  @@index([parentCommentId]) // for loading replies
  @@index([canvasId, isPinned, isAnnouncement]) // for featured comments
  @@index([canvasId, parentCommentId, isDeleted, netScore]) // for paginated top-level comments sorted by score
  @@map("comments")
}

model CommentVote {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  voteType  VoteType
  userId    String // UUID reference to User
  commentId Int

  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  comment Comment @relation(fields: [commentId], references: [id], onDelete: Cascade)

  @@unique([userId, commentId]) // one vote per user per comment
  @@index([commentId, voteType]) // for counting votes by type
  @@map("comment_votes")
}

// MODERATION & REPORTING

model SubjectModerator {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  userId    String // UUID reference to User
  subjectId Int

  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  subject Subject @relation(fields: [subjectId], references: [id], onDelete: Cascade)

  @@unique([userId, subjectId]) // one moderator role per user per subject
  @@index([subjectId]) // for finding moderators of a subject
  @@index([userId]) // for user's moderated subjects
  @@map("subject_moderators")
}

model Report {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  reason            ReportReason
  description       String?
  status            ReportStatus @default(PENDING)
  resolutionNotes   String?
  resolvedAt        DateTime?
  reporterUserId    String // UUID reference to User
  reportedCanvasId  Int? // One of these three must be non-null
  reportedCommentId Int?
  reportedUserId    String?
  resolvedBy        String? // UUID reference to User (admin/moderator)

  reporter        User     @relation("ReportedBy", fields: [reporterUserId], references: [id], onDelete: Cascade)
  reportedCanvas  Canvas?  @relation(fields: [reportedCanvasId], references: [id], onDelete: SetNull)
  reportedComment Comment? @relation(fields: [reportedCommentId], references: [id], onDelete: SetNull)
  reportedUser    User?    @relation("ReportedUser", fields: [reportedUserId], references: [id], onDelete: SetNull)
  resolver        User?    @relation("ResolvedBy", fields: [resolvedBy], references: [id], onDelete: SetNull)

  @@index([status, createdAt]) // for moderation queue
  @@index([reporterUserId]) // for user's reports
  @@index([reportedCanvasId]) // for canvas reports
  @@index([reportedCommentId]) // for comment reports
  @@index([reportedUserId]) // for user reports
  @@index([resolvedBy]) // for moderator activity
  @@map("reports")
}

model UserPoints {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  points    Int      @default(0)
  earnedAt  DateTime @default(now())
  reason    String? // "content_approved", "quiz_completed", "helpful_comment", etc.
  userId    String // UUID reference to User
  subjectId Int? // null for global points

  user    User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  subject Subject? @relation(fields: [subjectId], references: [id], onDelete: SetNull)

  @@index([userId, earnedAt]) // for user point history
  @@index([subjectId, earnedAt]) // for subject leaderboards
  @@index([earnedAt]) // for global leaderboards
  @@map("user_points")
}
